using Ergosfare.Core.Abstractions.EventHub;
using Ergosfare.Core.Test.SignalHub;
using Ergosfare.Test.Fixtures;
using Ergosfare.Test.Fixtures.Stubs.Basic;

namespace Ergosfare.Core.Test.EventHub;

/// <summary>
/// Unit tests for verifying <c>HubEvent</c> behavior,
/// including equality, hashing, related event management, 
/// and timestamp correctness.
/// </summary>
/// <remarks>
/// Equality between <c>HubEvent</c> instances is determined 
/// by all structural components of the event, including:
/// - Message type
/// - Handler count
/// - Event kind / metadata
/// 
/// <para>
/// The following components are ignored in equality comparisons:
/// - Timestamp
/// - RelatedEvents collection
/// </para>
/// 
/// Events generated by stubs with the same components (except timestamp and RelatedEvents)
/// are considered equal, even if they are different instances.
/// </remarks>
public class HubSignalTests(
    SignalHubFixture signalHubFixture) : BaseSignalFixture(signalHubFixture)
{
    /// <summary>
    /// Verifies that two events generated with the same components
    /// (message type and handler count) are considered equal.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void HubEventsShouldBeEqual()
    {
        // Arrange: two events with same message type and handler count
        var event1 = SignalHubFixture.BeginHandlingEvent<StubMessage>(1);
        var event2 = SignalHubFixture.BeginHandlingEvent<StubMessage>(1);

        // Act: compare using == and Equals
        var equality1 = event1 == event2;
        var equality2 = event1.Equals(event2);

        // Assert: both equality checks pass and hash codes match
        Assert.True(equality1);
        Assert.True(equality2);
        Assert.Equal(event1.GetHashCode(), event2.GetHashCode());
    }

    /// <summary>
    /// Verifies that events with different handler counts
    /// are not considered equal.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void HubEventsShouldNotBeEqual()
    {
        // Arrange: same message type, different handler count
        var event1 = SignalHubFixture.BeginHandlingEvent<StubMessage>(1);
        var event2 = SignalHubFixture.BeginHandlingEvent<StubMessage>(2);

        // Act: compare using == and Equals
        var equality1 = event1 == event2;
        var equality2 = event1.Equals(event2);

        // Assert: both equality checks fail and hash codes differ
        Assert.False(equality1);
        Assert.False(equality2);
        Assert.NotEqual(event1.GetHashCode(), event2.GetHashCode());
    }

    /// <summary>
    /// Ensures that <see cref="HubEvent.GetHashCode"/> aggregates
    /// all relevant components for equality comparison (except timestamp and related events).
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void GetHashCode_ShouldAggregateAllComponents()
    {
        // Act
        var hash = Signal.GetHashCode();

        // Assert: returns an integer
        Assert.IsType<int>(hash);
    }

    /// <summary>
    /// Verifies that a single related event can be added.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void Add_ShouldAddRelatedEvent()
    {
        var parent = SignalHubFixture.BeginPipelineEvent<StubMessage>();

        // Act
        parent.Add(Signal);

        // Assert
        Assert.Single(parent.RelatedEvents);
        Assert.Contains(Signal, parent.RelatedEvents);
    }

    /// <summary>
    /// Verifies that multiple related events can be added at once.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void AddRange_ShouldAddMultipleRelatedEvents()
    {   
        var parent = SignalHubFixture.BeginPipelineEvent<StubMessage>();

        // Act
        parent.AddRange(Signal, Signal);

        // Assert
        Assert.Equal(2, parent.RelatedEvents.Count);
        Assert.Contains(Signal, parent.RelatedEvents);
    }

    /// <summary>
    /// Verifies that the <see cref="HubEvent.RelatedEvents"/> collection is read-only.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void RelatedEvents_ShouldBeReadOnly()
    {
        var parent = SignalHubFixture.BeginPipelineEvent<StubMessage>();
        parent.Add(Signal);

        // Attempting to modify the list directly should throw
        var relatedEvents = parent.RelatedEvents;
        Assert.Throws<NotSupportedException>(() => ((System.Collections.IList)relatedEvents).Add(Signal));
    }

    /// <summary>
    /// Verifies that adding related events does not affect event equality.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void RelatedEvents_AddedEventsDoNotAffectEquality()
    {
        var a = SignalHubFixture.BeginPipelineEvent<StubMessage>();
        var b = SignalHubFixture.BeginPipelineEvent<StubMessage>();

        // Act
        a.Add(Signal);

        // Assert: equality ignores RelatedEvents collection
        Assert.Equal(a, b);
        Assert.Equal(a.GetHashCode(), b.GetHashCode());
    }

    /// <summary>
    /// Verifies that event timestamps are set close to creation time.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void RelatedEvents_ShouldGetTimestamp()
    {
        var now = DateTime.UtcNow;

        // Assert: timestamp is before now and within a 2-second range
        Assert.True(Signal.Timestamp < now);
        Assert.InRange(Signal.Timestamp, now.AddSeconds(-2), now.AddSeconds(2));
    }

    /// <summary>
    /// Verifies that a HubEvent does not equal unrelated objects.
    /// </summary>
    [Fact]
    [Trait("Category", "Unit")]
    [Trait("Category", "Coverage")]
    public void RelatedEvents_ShouldNotEqual()
    {
        var other = new object();

        // Assert: HubEvent not equal to unrelated object
        Assert.NotEqual(Signal, other);
    }
}
